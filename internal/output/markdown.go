package output

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/emilushi/prereview/internal/review"
)

// MarkdownGenerator generates markdown output for review suggestions
type MarkdownGenerator struct {
	outputDir string
}

// NewMarkdownGenerator creates a new markdown generator
func NewMarkdownGenerator(outputDir string) *MarkdownGenerator {
	if outputDir == "" {
		outputDir = "."
	}
	return &MarkdownGenerator{
		outputDir: outputDir,
	}
}

// GenerateSuggestionsFile creates a markdown file with all suggestions
func (g *MarkdownGenerator) GenerateSuggestionsFile(result *review.ReviewResult) (string, error) {
	if result == nil {
		return "", fmt.Errorf("review result cannot be nil")
	}
	commitHash := getShortCommitHash()
	filename := fmt.Sprintf("suggestions_%s.md", commitHash)

	// Try to find .github folder location for output
	outputPath := g.findOutputPath(filename)

	content := g.generateMarkdownContent(result, commitHash)

	if err := os.WriteFile(outputPath, []byte(content), 0644); err != nil {
		return "", fmt.Errorf("failed to write markdown file: %w", err)
	}

	return outputPath, nil
}

// findOutputPath determines where to save the markdown file
func (g *MarkdownGenerator) findOutputPath(filename string) string {
	// If custom output dir specified, use it
	if g.outputDir != "." && g.outputDir != "" {
		// Ensure the directory exists
		if err := os.MkdirAll(g.outputDir, 0755); err == nil {
			return filepath.Join(g.outputDir, filename)
		}
		// Fall through to default behavior if directory creation fails
	}

	// Try to find repo root (where .github folder typically is)
	cmd := exec.Command("git", "rev-parse", "--show-toplevel")
	output, err := cmd.Output()
	if err == nil {
		repoRoot := strings.TrimSpace(string(output))
		if repoRoot != "" {
			return filepath.Join(repoRoot, filename)
		}
	}

	// Default to current directory
	return filename
}

// generateMarkdownContent creates the markdown content
func (g *MarkdownGenerator) generateMarkdownContent(result *review.ReviewResult, commitHash string) string {
	var sb strings.Builder

	// Header
	sb.WriteString("# Code Review Suggestions\n\n")
	sb.WriteString(fmt.Sprintf("**Generated:** %s  \n", time.Now().Format("2006-01-02 15:04:05")))
	sb.WriteString(fmt.Sprintf("**Commit:** `%s`  \n", commitHash))
	sb.WriteString(fmt.Sprintf("**Files Reviewed:** %d  \n", len(result.Files)))
	sb.WriteString(fmt.Sprintf("**Total Suggestions:** %d  \n\n", len(result.Suggestions)))

	if len(result.Suggestions) == 0 {
		sb.WriteString("‚úÖ **No issues found!** Your code looks good.\n")
		return sb.String()
	}

	// Table of contents
	sb.WriteString("## Summary\n\n")
	sb.WriteString("| Severity | Count |\n")
	sb.WriteString("|----------|-------|\n")

	severityCounts := countBySeverity(result.Suggestions)
	for _, sev := range []review.Severity{review.SeverityError, review.SeverityWarning, review.SeverityInfo, review.SeverityHint} {
		if count, ok := severityCounts[sev]; ok && count > 0 {
			sb.WriteString(fmt.Sprintf("| %s | %d |\n", severityEmoji(sev), count))
		}
	}
	sb.WriteString("\n")

	// Group suggestions by file
	byFile := groupByFile(result.Suggestions)

	sb.WriteString("## Suggestions by File\n\n")

	for _, file := range result.Files {
		suggestions, ok := byFile[file]
		if !ok || len(suggestions) == 0 {
			continue
		}

		sb.WriteString(fmt.Sprintf("### üìÑ `%s`\n\n", file))

		for i, sug := range suggestions {
			sb.WriteString(fmt.Sprintf("#### %d. %s %s\n\n", i+1, severityEmoji(sug.Severity), sug.Title))

			// Location
			if sug.Line > 0 {
				if sug.EndLine > 0 && sug.EndLine != sug.Line {
					sb.WriteString(fmt.Sprintf("**Lines:** %d-%d  \n", sug.Line, sug.EndLine))
				} else {
					sb.WriteString(fmt.Sprintf("**Line:** %d  \n", sug.Line))
				}
			}

			// Category
			if sug.Category != "" {
				sb.WriteString(fmt.Sprintf("**Category:** `%s`  \n\n", sug.Category))
			} else {
				sb.WriteString("\n")
			}

			// Description
			sb.WriteString(sug.Description + "\n\n")

			// Original code and suggested fix
			if sug.OriginalCode != "" && sug.OriginalCode != "N/A" {
				sb.WriteString("**Original Code:**\n\n")
				sb.WriteString("```\n")
				sb.WriteString(sug.OriginalCode)
				if !strings.HasSuffix(sug.OriginalCode, "\n") {
					sb.WriteString("\n")
				}
				sb.WriteString("```\n\n")
			}

			if sug.SuggestFix != "" && sug.SuggestFix != "N/A" {
				sb.WriteString("**Suggested Fix:**\n\n")
				sb.WriteString("```\n")
				sb.WriteString(sug.SuggestFix)
				if !strings.HasSuffix(sug.SuggestFix, "\n") {
					sb.WriteString("\n")
				}
				sb.WriteString("```\n\n")
			}

			sb.WriteString("---\n\n")
		}
	}

	// Footer
	sb.WriteString("\n---\n\n")
	sb.WriteString("*Generated by [PreReview](https://github.com/emilushi/prereview)*\n")

	return sb.String()
}

// getShortCommitHash returns the short hash of the current HEAD or staged changes
func getShortCommitHash() string {
	// Try to get HEAD commit hash
	cmd := exec.Command("git", "rev-parse", "--short", "HEAD")
	output, err := cmd.Output()
	if err == nil {
		hash := strings.TrimSpace(string(output))
		if hash != "" {
			return hash
		}
	}

	// Fallback to timestamp if no commits yet
	return fmt.Sprintf("staged_%d", time.Now().Unix())
}

// countBySeverity counts suggestions by severity
func countBySeverity(suggestions []review.Suggestion) map[review.Severity]int {
	counts := make(map[review.Severity]int)
	for _, s := range suggestions {
		counts[s.Severity]++
	}
	return counts
}

// groupByFile groups suggestions by file
func groupByFile(suggestions []review.Suggestion) map[string][]review.Suggestion {
	grouped := make(map[string][]review.Suggestion)
	for _, s := range suggestions {
		grouped[s.File] = append(grouped[s.File], s)
	}
	return grouped
}

// severityEmoji returns an emoji for the severity level
func severityEmoji(sev review.Severity) string {
	switch sev {
	case review.SeverityError:
		return "üî¥ Error"
	case review.SeverityWarning:
		return "üü° Warning"
	case review.SeverityInfo:
		return "üîµ Info"
	case review.SeverityHint:
		return "üí° Hint"
	default:
		return "üìù Note"
	}
}
